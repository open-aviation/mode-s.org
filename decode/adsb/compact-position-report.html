<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

  <meta name="author" content="Junzi Sun">


  <title>The 1090MHz Riddle</title>
  <style type="text/css">code{white-space: pre;}</style>



  <link rel="stylesheet" href="../bootstrap.min.css">
  <link rel="stylesheet" href="../style.css">

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<link href="https://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet">

</head>
<body>

<div class="container">

<div class="d-flex flex-row align-items-end">
	<div>
		<h1 class="title">The 1090MHz Riddle</h1>
		<div class="subtitle">An open-access book about decoding Mode-S and ADS-B data</div>
	</div>
	<div class='ml-auto chapter-nav'>
    <div class="author">By: <strong>Junzi Sun</strong> (<a href="http://junzis.com">junzis.com</a>)</div>
    <a href="http://mode-s.org" type="button" class="btn btn-sm btn-outline-dark btn-light">mode-s.org</a>
    <a href="../book-the_1090mhz_riddle-junzi_sun.pdf" type="button" class="btn btn-sm btn-outline-info">Download PDF</a>
	</div>
</div>

<hr>

<div class="row">
<div class="col-md-4 col-lg-3">
<nav>
  <h1>Chapters</h1>
  <ul>
    <li><a href="../index.html">Introduction</a></li>
    <li><a href="../adsb.html">ADS-B</a></li>
    <ul>
      <li><a href="../adsb/introduction.html">Basics</a></li>
      <li><a href="../adsb/identification.html">Aircraft Identification</a></li>
      <li><a href="../adsb/compact-position-report.html">Compact Position Reporting</a></li>
      <li><a href="../adsb/airborne-position.html">Airborne Position</a></li>
      <li><a href="../adsb/airborne-velocity.html">Airborne Velocity</a></li>
    </ul>
    <li><a href="../adsb/advance.html">Advanced ADS-B</a></li>
    <ul>
      <li><a href="../adsb/version.html">ADS-B Versions</a></li>
      <li><a href="../adsb/operation-status.html">Operation Status</a></li>
      <li><a href="../adsb/uncertainty.html">Uncertainty and Accuracy</a></li>
    </ul>
    <li><a href="../ehs.html">Enhanced Mode-S</a></li>
    <ul>
      <li><a href="../ehs/introduction.html">Basics</a></li>
      <li><a href="../ehs/bds20-identification.html">Aircraft Identification</a></li>
      <li><a href="../ehs/bds40-intention.html">Aircraft Intention</a></li>
      <li><a href="../ehs/bds50-track-n-turn.html">Track and Turn</a></li>
      <li><a href="../ehs/bds60-airspeed.html">Airspeed and Heading</a></li>
    </ul>
  </ul>
</nav>
<hr>
<nav id="TOC">
<h1>In this page</h1>
<ul>
<li><a href="#compact-position-reporting">Compact Position Reporting</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#the-cpr-and-functions">The CPR and functions</a><ul>
<li><a href="#nz">NZ</a></li>
<li><a href="#floorx">floor(x)</a></li>
<li><a href="#modx-y">mod(x, y)</a></li>
<li><a href="#nllat">NL(lat)</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
</div>
<div class="col-md-8 col-lg-9 maintext">
<h1 id="compact-position-reporting">Compact Position Reporting</h1>
<p>The position information in ADS-B messages is encoded in a compact position reporting (CPR) format. The general idea behind CPR is to be able to encode more coordinate decimals using less bits. It is achieved by trading global position ambiguity and time with local position accuracy.</p>
<h2 id="example">Example</h2>
<p>An easy example to understand the principle behind CPR:</p>
<p>Imaging the world is constructed by 16 grid, which we have divided into two levels, each level is encoded with two bits. Higher levels in color are <code>00</code> (yellow), <code>01</code> (blue), <code>10</code> (red), <code>11</code> (green). And within each color grid, the lower levels are also encoded similarly.</p>
<p>Then each grid can be represented as 4 digits from <code>0000</code> to <code>1111</code>. Now, we want to describe the movement indicated as the arrows in the green grids <code>1100 -&gt; 1101</code>, but we only have 3 bits to encode each position.</p>
<p><embed src="images/illustration-cpr-1.svg" width="302" /></p>
<p>It is easy to see that the high 2 bits appeared in all positions, so we can define a structure to do the following:</p>
<ol>
<li><p>The last two bits shall represent the local position</p></li>
<li><p>The combination of first digit from two messages defines the higher grid</p></li>
</ol>
<p>Then the two messages can be sent as <code>1 00 -&gt; 1 01</code>.</p>
<p>From lower bits <code>00 -&gt; 01</code>, we have four different possibility of movement as shown in dashed arrows, and from the two first bits combination <code>11</code>, we know that the arrow shall represent the movement in the green grids:</p>
<p><embed src="images/illustration-cpr-2.svg" width="207" /></p>
<h2 id="the-cpr-and-functions">The CPR and functions</h2>
<p>The actual CPR algorithm of course is more complicated, but the principle is very similar to the previous example. If only one message is given, it is possible to find multiple solutions that are spaced around the world. The combination of two (different types of) messages will yield the final result.</p>
<p>In CPR encoding, the Earth is divided in many zones (similar to the grid in the previous example). And the encoding algorithm is also more complicated (described in a later section). First, we will list some of the parameters and common functions used in the decoding process here.</p>
<h3 id="nz">NZ</h3>
<p>Number of geographic latitude zones between equator and a pole. It is set to <code>NZ = 15</code> for Mode-S CPR encoding.</p>
<h3 id="floorx">floor(x)</h3>
<p>the floor function <code>floor(x)</code> defines as the greatest integer value k, such that <code>k&lt;=x</code>, for example: :</p>
<pre><code>floor(5.6) = 5
floor(-5.6) = -6</code></pre>
<h3 id="modx-y">mod(x, y)</h3>
<p>the modulus function <code>mod(x, y)</code> returns:</p>
<p><span class="math display">\[x - y \cdot floor(\frac{x}{y})\]</span></p>
<p>where <code>y</code> can not be zero</p>
<h3 id="nllat">NL(lat)</h3>
<p>Denotes the “number of longitude zones” function, given the latitude angle <code>lat</code>. The returned integer value is constrained within <code>[1, 59]</code>, calculated as:</p>
<p><span class="math display">\[\text{NL}(lat) = floor \left( \frac{2 \pi}{\arccos(1 - \frac{1-\cos(\frac{\pi}{2 \cdot \text{NZ}})}{\cos^2(\frac{\pi}{180} \cdot \text{lat})}) } \right)\]</span></p>
<p>For latitudes that are close to the equator or the poles, one of following values is returned: :</p>
<pre><code>lat = 0     -&gt;    NL = 59
lat = +87   -&gt;    NL = 2
lat = -87   -&gt;    NL = 2
lat &gt; +87   -&gt;    NL = 1
lat &lt; -87   -&gt;    NL = 1</code></pre>
</div>
</div>

</body>
</html>
